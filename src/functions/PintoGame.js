// src/functions/PintoGame.js
const path = require('path');
const Logger = require('../utils/Logger');
const ReturnMessage = require('../models/ReturnMessage');
const Command = require('../models/Command');
const Database = require('../utils/Database');

const logger = new Logger('pinto-game');
const database = Database.getInstance();

// Constantes do jogo
const MIN_FLACCID = 0.5;
const MAX_FLACCID = 15.0;
const MIN_ERECT = 0.5;
const MAX_ERECT = 40.0;
const MIN_GIRTH = 6.0;
const MAX_GIRTH = 20.0;
const MAX_SCORE = 1000;
const COOLDOWN_DAYS = 7; // 7 dias de cooldown

// Armazena os cooldowns por usu√°rio
const playerCooldowns = {};

/**
 * Gera um valor aleat√≥rio entre min e max com 1 casa decimal
 * @param {number} min - Valor m√≠nimo
 * @param {number} max - Valor m√°ximo
 * @returns {number} - Valor aleat√≥rio com 1 casa decimal
 */
function generateRandomValue(min, max) {
  const value = Math.random() * (max - min) + min;
  return Math.round(value * 10) / 10; // Arredonda para 1 casa decimal
}

/**
 * Calcula o score com base nos valores
 * @param {number} flaccid - Comprimento fl√°cido
 * @param {number} erect - Comprimento ereto
 * @param {number} girth - Circunfer√™ncia
 * @returns {number} - Score calculado
 */
function calculateScore(flaccid, erect, girth) {
  // Normaliza os valores (0 a 1)
  const normFlaccid = (flaccid - MIN_FLACCID) / (MAX_FLACCID - MIN_FLACCID);
  const normErect = (erect - MIN_ERECT) / (MAX_ERECT - MIN_ERECT);
  const normGirth = (girth - MIN_GIRTH) / (MAX_GIRTH - MIN_GIRTH);
  
  // Calcula a m√©dia ponderada (dando mais peso para o comprimento ereto)
  const weightedAvg = (normFlaccid * 0.3 + normErect * 0.5 + normGirth * 0.2);
  
  // Converte para o score final
  return Math.round(weightedAvg * MAX_SCORE);
}

/**
 * Gera um coment√°rio com base no score
 * @param {number} score - Score calculado
 * @returns {string} - Coment√°rio engra√ßado
 */
function getComment(score) {
  if (score >= 900) {
    return "üî• Impressionante! Voc√™ est√° no n√≠vel lend√°rio!";
  } else if (score >= 800) {
    return "üèÜ Excepcional! Um verdadeiro campe√£o!";
  } else if (score >= 700) {
    return "üåü Incr√≠vel! Sem palavras para descrever!";
  } else if (score >= 600) {
    return "üëè Muito bem! Acima da m√©dia!";
  } else if (score >= 500) {
    return "üëç Bom resultado! Na m√©dia superior!";
  } else if (score >= 400) {
    return "üòä Resultado decente! Na m√©dia!";
  } else if (score >= 300) {
    return "üôÇ Resultado aceit√°vel. Um pouco abaixo da m√©dia.";
  } else if (score >= 200) {
    return "üòê Humm... N√£o √© o melhor resultado, mas tudo bem.";
  } else if (score >= 100) {
    return "üò¨ Eita... Pelo menos voc√™ tem personalidade, certo?";
  } else {
    return "üíÄ F no chat... Mas tamanho n√£o √© documento!";
  }
}

/**
 * Formata data para exibi√ß√£o
 * @param {number} timestamp - Timestamp em milissegundos
 * @returns {string} - Data formatada
 */
function formatDate(timestamp) {
  const date = new Date(timestamp);
  return date.toLocaleDateString('pt-BR', {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });
}

/**
 * Gera os resultados do comando !pinto
 * @param {WhatsAppBot} bot - Inst√¢ncia do bot
 * @param {Object} message - Dados da mensagem
 * @param {Array} args - Argumentos do comando
 * @param {Object} group - Dados do grupo
 * @returns {Promise<ReturnMessage>} Mensagem de retorno
 */
async function pintoCommand(bot, message, args, group) {
  try {
    // Verifica se est√° em um grupo
    if (!message.group) {
      return new ReturnMessage({
        chatId: message.author,
        content: 'Este jogo s√≥ pode ser usado em grupos.'
      });
    }
    
    // Obt√©m IDs e nome
    const groupId = message.group;
    const userId = message.author;
    const userName = message.authorName || "Usu√°rio";
    
    // Verifica cooldown
    const now = Date.now();
    const lastUsed = playerCooldowns[userId] || 0;
    const cooldownMs = COOLDOWN_DAYS * 24 * 60 * 60 * 1000;
    
    if (now - lastUsed < cooldownMs) {
      const nextAvailable = new Date(lastUsed + cooldownMs);
      const timeUntil = nextAvailable - now;
      const daysUntil = Math.ceil(timeUntil / (24 * 60 * 60 * 1000));
      
      return new ReturnMessage({
        chatId: groupId,
        content: `‚è≥ ${userName}, voc√™ j√° realizou sua avalia√ß√£o recentemente.\n\nPr√≥xima avalia√ß√£o dispon√≠vel em ${daysUntil} dia(s), dia ${formatDate(nextAvailable)}.`
      });
    }
    
    // Gera os valores aleat√≥rios
    const flaccid = generateRandomValue(MIN_FLACCID, MAX_FLACCID);
    const erect = generateRandomValue(Math.max(flaccid, MIN_ERECT), MAX_ERECT); // Ereto √© no m√≠nimo igual ao fl√°cido
    const girth = generateRandomValue(MIN_GIRTH, MAX_GIRTH);
    
    // Calcula o score
    const score = calculateScore(flaccid, erect, girth);
    
    // Obt√©m um coment√°rio baseado no score
    const comment = getComment(score);
    
    // Atualiza o cooldown
    playerCooldowns[userId] = now;
    
    // Salva os resultados no banco de dados
    try {
      // Salva o resultado no ranking do grupo
      await savePlayerToGroupRanking(userId, userName, groupId, flaccid, erect, girth, score);
    } catch (dbError) {
      logger.error('Erro ao salvar dados do jogo:', dbError);
    }
    
    // Prepara a mensagem de resposta
    const response = `${userName}, fiz a an√°lise completa de seu membro e cheguei nos seguintes resultados:\n\n` +
                    `‚Ä¢ *Comprimento Fl√°cido:* ${flaccid.toFixed(1)} cm\n` +
                    `‚Ä¢ *Comprimento Ereto:* ${erect.toFixed(1)} cm\n` +
                    `‚Ä¢ *Circunfer√™ncia:* ${girth.toFixed(1)} cm\n` +
                    `‚Ä¢ *Score:* _${score} pontos_\n\n` +
                    `${comment}\n\n` +
                    `> Voc√™ pode voltar daqui a 1 semana para refazermos sua avalia√ß√£o.`;
    
    return new ReturnMessage({
      chatId: groupId,
      content: response
    });
  } catch (error) {
    logger.error('Erro no comando de pinto:', error);
    
    return new ReturnMessage({
      chatId: message.group || message.author,
      content: '‚ùå Erro ao processar o comando. Por favor, tente novamente.'
    });
  }
}

/**
 * Mostra o ranking do jogo Pinto
 * @param {WhatsAppBot} bot - Inst√¢ncia do bot
 * @param {Object} message - Dados da mensagem
 * @param {Array} args - Argumentos do comando
 * @param {Object} group - Dados do grupo
 * @returns {Promise<ReturnMessage>} Mensagem de retorno
 */
async function pintoRankingCommand(bot, message, args, group) {
  try {
    // Verifica se est√° em um grupo
    if (!message.group) {
      return new ReturnMessage({
        chatId: message.author,
        content: 'üèÜ O ranking do jogo s√≥ pode ser visualizado em grupos.'
      });
    }
    
    const groupId = message.group;
    
    // Obt√©m as vari√°veis customizadas
    const customVariables = await database.getCustomVariables();
    
    // Verifica se existem dados do jogo
    if (!customVariables.pintoGame || 
        !customVariables.pintoGame.groups || 
        !customVariables.pintoGame.groups[groupId] ||
        Object.keys(customVariables.pintoGame.groups[groupId]).length === 0) {
      return new ReturnMessage({
        chatId: groupId,
        content: 'üèÜ Ainda n√£o h√° dados para o ranking neste grupo. Use !pinto para participar!'
      });
    }
    
    // Converte para array para poder ordenar
    const players = Object.entries(customVariables.pintoGame.groups[groupId]).map(([id, data]) => ({
      id,
      ...data
    }));
    
    // Ordena por score (maior para menor)
    players.sort((a, b) => b.score - a.score);
    
    // Limita a 10 jogadores
    const topPlayers = players.slice(0, 10);
    
    // Prepara a mensagem de ranking
    let rankingMessage = `üçÜ *Ranking do Tamanho - ${group.name || "Grupo"}*\n\n`;
    
    topPlayers.forEach((player, index) => {
      const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
      rankingMessage += `${medal} ${player.name}: ${player.score} pontos\n`;
    });
    
    // Encontra a posi√ß√£o do autor da mensagem
    const authorPosition = players.findIndex(player => player.id === message.author);
    
    // Se o autor n√£o est√° no top 10, mas est√° no ranking
    if (authorPosition >= 10) {
      rankingMessage += `\n...\n\n`;
      rankingMessage += `${authorPosition + 1}. Voc√™: ${players[authorPosition].score} pontos`;
    }
    
    return new ReturnMessage({
      chatId: groupId,
      content: rankingMessage
    });
  } catch (error) {
    logger.error('Erro ao mostrar ranking do jogo:', error);
    
    return new ReturnMessage({
      chatId: message.group || message.author,
      content: '‚ùå Erro ao mostrar ranking. Por favor, tente novamente.'
    });
  }
}

/**
 * Salva os resultados do jogador no ranking do grupo
 * @param {string} userId - ID do usu√°rio
 * @param {string} userName - Nome do usu√°rio
 * @param {string} groupId - ID do grupo
 * @param {number} flaccid - Comprimento fl√°cido
 * @param {number} erect - Comprimento ereto
 * @param {number} girth - Circunfer√™ncia
 * @param {number} score - Pontua√ß√£o total
 * @returns {Promise<boolean>} - Status de sucesso
 */
async function savePlayerToGroupRanking(userId, userName, groupId, flaccid, erect, girth, score) {
  try {
    // Obt√©m vari√°veis customizadas
    const customVariables = await database.getCustomVariables();
    
    // Inicializa estrutura de dados se n√£o existir
    if (!customVariables.pintoGame) {
      customVariables.pintoGame = {
        groups: {},
        history: []
      };
    }
    
    if (!customVariables.pintoGame.groups) {
      customVariables.pintoGame.groups = {};
    }
    
    if (!customVariables.pintoGame.groups[groupId]) {
      customVariables.pintoGame.groups[groupId] = {};
    }
    
    // Salva ou atualiza os dados do jogador para este grupo
    customVariables.pintoGame.groups[groupId][userId] = {
      name: userName,
      flaccid,
      erect,
      girth,
      score,
      lastUpdated: Date.now()
    };
    
    // Adiciona ao hist√≥rico geral
    if (!customVariables.pintoGame.history) {
      customVariables.pintoGame.history = [];
    }
    
    customVariables.pintoGame.history.push({
      userId,
      userName,
      groupId,
      flaccid,
      erect,
      girth,
      score,
      timestamp: Date.now()
    });
    
    // Limita o hist√≥rico a 100 entradas
    if (customVariables.pintoGame.history.length > 100) {
      customVariables.pintoGame.history = customVariables.pintoGame.history.slice(-100);
    }
    
    // Salva as vari√°veis
    await database.saveCustomVariables(customVariables);
    
    return true;
  } catch (error) {
    logger.error('Erro ao salvar jogador no ranking do grupo:', error);
    return false;
  }
}


// Criar array de comandos usando a classe Command
const commands = [
  new Command({
    name: 'pinto',
    description: 'Gera uma avalia√ß√£o de tamanho aleat√≥ria',
    category: "jogos",
    cooldown: 0, // 1 minuto de cooldown entre tentativas (o cooldown real √© controlado internamente)
    reactions: {
      before: "üìè",
      after: "üçÜ",
      error: "‚ùå"
    },
    method: pintoCommand
  }),
  
  new Command({
    name: 'pinto-ranking',
    description: 'Mostra o ranking do jogo',
    category: "jogos",
    cooldown: 30,
    reactions: {
      after: "üèÜ",
      error: "‚ùå"
    },
    method: pintoRankingCommand
  })
];

module.exports = { commands };