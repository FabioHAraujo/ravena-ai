Implement a whatsapp chatbot using whatsapp-web.js 1.27.0.
Do not use TypeScript.

The main file should be able to create multiple instances of the bot for different numbers 
The interface must be a class that can be instantiated multiple times in the same process, receiving the needed parameters, such as the class which will handle the events. Those instances must have a specifiable ID when creating the object and the phone number to request pairing code.

There should be a locally managed and backed up database, JSON format, to store group and user data, commands and whatever else is necessary. If a current file read error ocurrs when loading, get the latest backup automatically.
Implement a logger class that logs to log folder with the bot it in the name and autorotate files nightly, also print loggin to terminal.
The instances will run in parallel, but share the same database.

Mainly, it must support handling common events:

- connected and disconnected
- message: main event, where messages are received, processed and replied to
- groupJoin and groupLeave: Fired when user joins a group
- notification: Will be used for monitoring twitch, kick, youtube and other platforms new videos and streams. I will implement those methods later.

Received messages can be commands, defined by a starting character, default prefix when creating the bot is '!'
There are 3 command types and it should check if message is one of them in this order:
- fixed commands: Defined by classes on 'functions' folder, specified and imported in a fixed-cmds class. Give me placeholders for some of them like !weather, !ping

- custom commands: Created and managed by users on a per-group basis. Each group has it's own custom commands file in the custom-cmd folder. 

- management: Fixed and defined on a management class. Use to change group properties, CRUD custom commands. Start with g, like !g-setName: setName, addCmd, addCmdReply, delCmd, enableCmd, disableCmd, setCustomPrefix, setWelcome, setFarewell
- Management extra: Users can send !g-manage [groupName] and then their private chat with the bot will be handled like it's in the group, so that they can manage the group from outside

- On the command handler, it should load the complete list (get for each type) before trying to check if the received message is one of them.

- About: g-addCmd: It must be a reply of a message and content is that mentioned message. Type is based on the mentioned message.
- Also implement g-addCmdReply [command]: Almost the same, but adds a new response to the specified command

A CommandHandler should be implemented to check if a received message is a command, and if it is, call the apropriate handler spcified
commands.json (example). This method should be called by the eventHandler onMessage
The text to check in the message is the message body if it's a text message or the caption in case of media
[
{
	"startsWith": "g-",
	"contais": "setName", // This would handle messages like !g-setName
	"method": management.setGroupTitle,
	"ignorePrefix": true|false,
	"needsMedia": true|false, // message must have media
	"customCheck: "functionName" | calls specified function with the message content
}
]

Custom commands are a bit different:
[
{
	"startsWith": "bom dia",
	"type": text|sticker|image|video|gif,
	"responses": ["Reponse 1", "Response 2", "Today is {day}", "Custom riable {pokemon}", "{img-imageVa_name.png} The image caption"],
	"sendAllResponses": true|false, // send all responses in order if true, false selects a random one to send
	"mentions": [], // array of people to mention in the command. Enables {mention1}, {mention2}, ... variables
	"cooldown": 30,
	"react": "👌",
	"reply": true|false,
	"count": 0, // times used
	"period": {"start": "07:00", "end": "08:00"}, // command can only be used between 7 and 8 am
	"expires": "2025-12-01", // not avaiable after this date
	"metadata": {}, // create by, timestamp created
	"active": true|false,
	"deleted": true|false,


}
]
Their reply string can have custom variables defined in a json file custom-variables.json
They can send files like img-fileName, audio-fileName, voice-fileName, etc. Those files should be saved in the data folder whenever a custom command is created
Some variables can be dinamically specified in a processCustomVariables method - like time and date, api responses, server info, etc.

The called handler must a receive the mesage properties like:
ReceivedMessage {
	group: group Id,
	author: sender Id,
	type: text|sticker|image|video|audio|voice
	content: based on media type
	*caption: if media
	origin: message object from the original source
}


Group class will store relevant group data, such as the ID to send messages via the API, name for the users to interface with, twitch, kick and youtube channels that will be monitored asynchronously
{
	id: 123456@g.us,
	addedBy: 123456@c.us,
	removedBy: 123@c.us // if removed from group, store who removed, starts false
	name: group title, all lowercase, but no spaces, limited to 16 characters, default is current title in this format
	prefix: "!", // character prefix for group
	inviteCode: if avaiable,
	paused: true/false,
	filters: { // if message contains these filters, delete the message from the chat
		"nsfw": true/false,
		"links": true/false,
		"words": [],
		"people": [],
	},
	twitch: [{
		"name": "channel",
		"titles": {
			"on": "[ON] channel",
			"off": "[OFF] channel"
		},
		"changeTitle": switch|defined|false,
		"media": {
			"text": "estou on",
			"image": "image.jpg",
			"video":"video.mp4",
			"gif": "gif.mp4",
			"sticker": "image.png"
		}
	}],
	kick: [], // same as twitch
	youtube: ["uid-001","uid-003"] // monitored channels id
	"greetings": {"text": "Bem vindo, {pessoa}!", "sticker": "image.png", "video"... }, // Sent to the group when someone joins
	"farewells": {"text": "Tchau, {pessoa}!"}, // Sent to the group when someone leaves

}

When joining a group, create a new group object with the specified data and save to database.
Send a welcome message to this group. This message should be generated on a custom function generateGreetingMessage and be sent to the group when joining.
This function receives the group title, group description and number of members.
There are 2 kinds of welcome message to be fired
1. The bot itself joined the group: Create the group on the database and send two messages, a default one with the botinfo and a LLM generated one with the group info (title, description and number of members)
2. Someone else joined the group: Send the defined group.greetings message with processed variables (who joined etc.)

Create a file with functions to call LLM API through OpenRouter, use official libraries if avaiable. Also provide functions to call a local LLM on LmStudio (OpenAI API). They should be avaiable for use in the commands and group join events.

---

Message Flow:
1. User sends a message
2. WhatsAppBot receives and formats the message
3. Message is passed to EventHandler's onMessage
4. EventHandler checks if it's a command based on prefix
5. If it's a command, it's routed to CommandHandler
6. CommandHandler determines the command type and executes it
7. If not a command, it's processed by EventHandler.processNonCommandMessage (such as filters or commands that can be auto triggered)

Streaming platform flow:
1. Event for channel XXX on platform YYY is fired
2. Check which groups are monitoring XXX@YYY
3. For each group, generate the notificatin message based on the group configuration for this platform (simple text, media, etc.)
3.1 Default is just a text message saying "xxx is online on link https..!" or "is offline."
4. Send the async messages to the groups

I need a simple way to test the bot without initiating a whatsapp connection.
Create a way to fire the events async from another script (while the main bot is running).
Like a fake version of WhatsAppBot.js that receives the events from a web api or file which can be called from a separate program and generate whatsapp-web.js objects
No need to be a complex, a simple test.js file is ok.
Joinig the group, should be the first one
Even though this is a test script, everything should in the same production code and get/modify data from the real database


Use .env file for configurations like API keys, provide .env.example

Create a bat file for windows to create the folder and files structure with placeholder text (files can be empty so I can copypaste from claude)

Small change to group_join
There are 2 kinds of welcome message to be fired
1. The bot itself joined the group: Create the group on the database and send two messages, a default one with the botinfo and a LLM generated one with the group info (title, description and number of members)
2. Someone else joined the group: Send the defined group.greetings message with processed variables (who joined etc.)


Issues When creating or modifying commands
1. The loaded on memory databse is not being updated, only the persistent files. This means that after creating a custom command, the bot needs to be restarted.
2. Media commands like stickers, images, audios, video, etc. should not save the base64 preview, but must intead download the MessageMedia and write to a file in the data/custom-cmd/media folder. The path to the saved media is what must be placed in the responses of the new command, so that sendCustomCommandResponse can properly locate and load the media into a MessageMedia


---
Implement new features:

## New type of Command
Normally, a command is defined if the string starts with the prefix
Create a new type of handler that is if the message starts with the bot number mention "@${botNumber}".
This defaults to invoking the LLM getCompletion (openrouter) method and returning the result as text

## Loadreport logging
Each WhatsAppBot.js should keep track of number of messages received and sent (in groups and outside separately) every 10 minutes
Store this on the database and call it loadreport

## Community group notifications:
When initializing the bots, the constructor can receive 4 group IDs: grupoLogs, grupoInvites, grupoAvisos and grupoInteracao
If set, this is the intendet behavior:
- grupoLogs: Send log messages like the loadreport every 10 minutes, send message when initialized, send message when added/removed to/from a group
- grupoAvisos and grupoInteracao: When receiving a donation notification, send message to these group mentioning all members

## External API
The bot should exposed an API on port 5000 with some methods.

# Implement /donate_tipa (Webhook from tipa.ai)

Example implementation:
botApi.post('/donate_tipa', async function (req, res) {
	let dadosDonate = JSON.stringify(req.headers,null,"\t")+"\n"+JSON.stringify(req.body,null,"\t");
	
	notifyGrupoLogs("Donate received:\n"+dadosDonate);

	const headerTipa = req.headers["x-tipa-webhook-secret-token"] ?? false;
	logger.info("[donate-tipa] Recebido request válido: ");

	const nome = req.body.payload.tip.name ?? "Alguém";
	const valor = parseFloat(req.body.payload.tip.amount);
	const msg = req.body.payload.tip.message ?? "";

	if(headerTipa === process.env.TIPA_TOKEN){
  		logger.info(`\t[moothz] ${nome} doou R$${valor} e enviou a seguinte mensagem: ${msg}`);

	  	if(valor > 0){
	  		const dadosMeta = updateDonateMeta(valor);

	  		let metaMsg = "";
	  		if(dadosMeta){
	  			metaMsg = `💰 *Meta*: _${dadosMeta.atual}_ de *${dadosMeta.meta}* alcançados\n${dadosMeta.motivo}\n\n`;
	  		} else {
	  			loggerWarn(`[donate] Erro buscando dados da meta`);
	  		}

	  		metaMsg = "";

			const msgDonate = `💸 Recebemos um *DONATE* no tipa.ai! 🥳\n\n${metaMsg}*MUITO obrigado* pelos _R$${valor.toFixed(2)}, ${nome}_! 🥰\nCompartilho aqui com todos sua mensagem:\n💬 _${msg}_\n\n\`\`\`!doar ou !donate pra conhecer os outros apoiadores e doar também\`\`\``;
			const tempoExtraDonate = Math.floor(parseFloat(valor)*300);

			const msgEnviadaDonateGrupao = await client.sendMessage(configs.idGrupaoZueira, msgDonate, { linkPreview: false });
			const msgEnviadaDonateAvisos = await client.sendMessage(configs.idGrupoAvisos, msgDonate, { linkPreview: false });
			try{
				msgEnviadaDonate.pin(600 + tempoExtraDonate);
				msgEnviadaDonateAvisos.pin(600 + tempoExtraDonate);
			} catch(e){
				loggerWarn(`[sistema] Erro dando pin na msg donate`);
			}


			notifyGrupoLogs(msgDonate);
			addValorDonate(nome,valor);
		}
	  	res.send('ok');
	}  else {
		res.send('-');
	}
});

notifyGrupoLogs, etc. should trigger send message on all the bot instances
They may trigger errors if the bot is not in that group, just log the error

## Database for donations
[
  {
    "nome": "Person Name",
    "valor": 2400,
    "numero": undefined
  }
]

numero is default undefined since we don't have t from the tipa api
Create a management commands:
	- !g-addDonateNumero [numero] [nome]: Add number to that person donate
	- !g-addDonateValor [valor] [nome]: Add/subtract float value to that person donate
	- !g-mergeDonates [nome1]##[nome2]: Nomes can have space, so use a delimiter to specify both and merge values to the nome1

# Implement POST /getLoad
Reads the loadreport for all bots that happend after the provided timestamp and returns a json

## Invite system
Bots can't simply be added to groups, this is how it works:

A person sends an invite link (chat.whatsapp.com) directly to the bot (not groups)
The bot then asks the person to send a message to explain why they want the bot in the group
After the person sends this message or it timesout (5 minutes), the bot sends 2 messages to grupoInvites: 
1. Contains person name, number and the message explaning why
2. Contains the formatted command tha makes the bot join the grupo using client.acceptInvite: !g-joinGrupo abcd1234
abcd1234 is the invite code from the end of the invite link

## Major change
This needs to be thought very carefully.

On the events, await should be avoided because it can lock up the thread and not process more messages
If that's the case, make sure to use promises or callbacks on API calls and other processing like downloading message media.
There will be function modules to download files and videos from some sources too, those will return promises and send the message only when long processing is done.

Commands can have two reaction emojis defined: before and after.
Default before is: ⏳
Default after is: ✅

As soon as a command is detected and ok to be processed (before calling the method), react to the message with the before emoji
When the command completes and the response is to be sent (sendMessage) react with the after emoji

----
Create a new command module name ImageManipulation
Use sharp, imagemagick, and rembg (python). Use trusted and updated npm modules for wrapping
Those commands will manipulate the providade image (command on caption or mentioned via reply, just like sticker making) and then return the result

    !removebg: Removes the image background and sharp.trim()
    !distort: Use mogrify liquify 30- 70% intensity, scale 200%
    Any other cool things to do with imagemagick

To make us of the removebg function, also implement a new sticker command:
* !stickerbg, !sbg: Removes the background/trim() before creating the sticker

Make sure to use promises instead of await

--
## Reaction

# Processing reactions
before and after reactions are working great, but there should be a new one for error - like when the user does not provide an image for a media needed command or the api fails.
Default emoji for error: ❌

# Receiving reactions 
A new handler ReactionsHandler. It should call a CommandHandler method to find a command by reaction to the message and create a fake message object (if needed only) to call the appropriate method. This is needed because a command reacts to the message that triggered the command, but if it's a reaction, there's no message - this is to avoid errors, but can be doen in a way you think is best.
Example reactions to implement now:
!sticker: 🖼
!stickerbg: ✂️
!removebg: 🪓
!ai: 🤖

Think of new emojis for the other commands, if you want.

## !ai and mentionhandler
[llm-service] Received response from OpenRouter API { status: 200, contentLength: 401 }
Seems ok, but not response is being sent back. Log the initial prompt and response also to better debug why

## ImageManipulation
Small change: removebg should return media as a file, not image

## Stickers.js
When creating stickers, set the author to "ravena" and the sticker name to what's after the command, if nothing, the group name
"!s batata" would create a sticker from the author "ravena" with the title "batata"


----

## Management
Now that commands support reactions create:
!g-setReact [command] [emoji] (after reaction)
!g-setStartReact [command] [emoji] (before reaction, default none)
Custom commands do not have reactions as default, only the error one ❌

## Cooler !menu and !cmd
If command has aliases (add property aliasFor in the commands definition) show them comma separated
If command can be activated with a reaction, show it in parenteshis like
!sticker, !s (🖼️)

Currently it is showing Fixed and managament commands, but also create a "Group Commands" list, shown first

## New Functions

# !atencao, !galera
Sends a message to the group and mention all members silently (do not show their name names on the messags, only the mentions array) (except opt-out from !ignorar command)

# !ignorar
Toggles member option to be ignored by the bot on random select functions and !atencao command
(save this as array in the group database)

# Text to speech
!tts command to convert text to speech. Use a good local and free library for this

# Speech to Text
!stt command to convert received audio/voice to text

Use a local and free library for this. Only language that needs to be supported is PT-BR
It's okay to use exec and call an external program.

If received audio outside of group (directly to bot), automatically begin converting
For groups, add managament commando !g-autoStt that toggles this functionality (only for messages of type 'voice')

# Summary
!resumo
Usable only inside groups.
Fetch the last 30 text messages sent (images caption too) like
Person 1: Message sent
Person 2: Message sent

If not possible to fetch, implement a way to keep group conversations in memory or in a json file (latest-messages-12345@g.us.json)

Send this conversation to the LLM and ask for a summary of what's going on in the group chat

# Interact
!interagir
Usable only inside groups.
Just like !resumo, but instead ask the LLM to generate a message to blend in with the group, like the bot knows the subject and wants to interact with a single short phrase, using similar language

# Search
!buscar, !google [string to search]
Search the web for this string.
Return a list of items. Use DuckDuckGo if there are avaiable packages.

!buscar-img to search for images, return random 5 images with their caption

---
Este projeto foi gerado pelo claude.

Preciso converter todos os textos de comentários e strings de respostas para PT-BR.
Analise arquivo por arquivo, localize para PT-BR e me envie os mesmos completos.

Não altere nomes de funções e variáveis, apenas comentários e strings de respostas e logs.
Não faça um script que faça isso, execute as mudanças aqui e irei copiá-las conferindo cada arquivo de uma vez.
Gere um artefato para cada arquivo, com o conteúdo completo de cada um deles.

---

## Modificações index
Caso CHROME_PATH esteja definido no .env, inicialize os bots com ele.
A variável HEADLESS_MODE .env define o headless
Padrão: true

puppeteer: {
	executablePath: chromePath,
	args: [ "--no-sandbox", "--disable-setuid-sandbox", "--disable-extensions", '--disable-gpu', "--disable-accelerated-2d-canvas", "--no-first-run", "--no-zygote", '--disable-dev-shm-usage'],
	headless: headlessMode
}

## Erros

# LLM
O LLM no openrouter está retornando vazio. A implementação está correta?

# SearchCommands
buscar-img não está retornando nenhuma imagem

## Nova function: Jogo-RoletaRussa
!roletarussa
Funciona apenas em grupos
Crie a roletarussa.json database

Quando usar o comando, existe 1 em 6 chances que o membro 'morre' no jogo, por um tempo pré definido em !g-setTempoRoleta [segundos], max 3600
Se morto, apenas reagir mensagem com ⚰️
Não pode ser usado em sequencia pela mesma pessoa, outra precisa tentar jogar antes
Cada grupo tem uma base de dados. O membro só morre dentro daquele grupo.
Guarde na base de dados, por membro: quantidade de tentativas atuais, maior quantidade sem morrer e numero de mortes totais

Resposta
Não morreu: 💨🔫 *click* - Tá *safe*! \`\`\`${tentativasAtuais}\`\`\`
Morreu: 💥🔫 *BANG* - _F no chat_ ${info}

Variável info info:
Se sobreviveu por mais tempo:
Morreu em ${qtdTentativasAtual}, um novo record! Seu máximo antes disso era ${qtdMaximaTentativas}.\nNeste grupo, você já morreu ${qtdMortes} vezes.
Caso contrário:
Morreu em ${qtdTentativasAtual}.\nNeste grupo, você já morreu ${qtdMortes} vezes.



!roletaranking
Funciona apenas em grupos
Mostra o ranking da roleta russa nesse formato:
emojisRanking = ["","🥇","🥈","🥉","🐅","🐆","🦌","🐐","🐏","🐓","🐇"]

🏆 Rankings Roleta Russa 🔫

🍀 Sorte - Máx. Tentativas sem morrer
	🥇 1°: 22 - Guilherme Recofka
	🥈 2°: 19 - Adolfinho
	🥉 3°: 16 - preto bosta
	🐅 4°: 15 - Bin laden
	🐆 5°: 15 - .
	🦌 6°: 12 - David
	🐐 7°: 11 - Alexandre Assis
	🐏 8°: 8 - Lord Mamazin
	🐓 9°: 6 - Vinicius🍎
	🐇 10°: 6 - Dark Schneider


🪦 Número de Mortes
	🥇 1°: 19 - Adolfinho
	🥈 2°: 18 - preto bosta
	🥉 3°: 16 - Lord Mamazin
	🐅 4°: 15 - Bin laden
	🐆 5°: 14 - Guilherme Recofka
	🦌 6°: 12 - Alexandre Assis
	🐐 7°: 7 - .
	🐏 8°: 5 - David
	🐓 9°: 3 - Vinicius🍎
	🐇 10°: 2 - Dark Schneider


---
## Roleta
Consertar um detalhe: O raking de "Max tentativas sem morrer" deve ser atualizado a cada novo tiro do usuário, não só quando ele morre, ou seja, se a pessoa jogou e não morreu ainda, ela deveria aparecer no ranking já.

## Nova functions FileManager.js

Funciona também no privado do bot, o grupo seria cosiderado o Id do usuário (@c.us)
!pastas: Lista as pastas e arquivos criadas no grupo, mostrando tamanho dos arquivos e o total utilizado no final
!p-criar: Cria nova pasta
!p-criar [destino]: Cria nova pasta dentro de [destino]
!p-enviar [destino\destino]: Envia arquivo na mensagem mencionada (quotedMessage) para a pasta destino. se destino tiver uma extensão, definir nome do arquivo pra ele, se não, pegar nome do arquivo enviado
!p-excluir [destino\arquivo.xxx]: Apaga o arquivo ou pasta especificado
!p-baixar [destino\arquivo.xxx]: O bot envia o arquivo especificado. Se for a pasta, envia todos da pasta

Tamanho máximo arquivo: 100Mb
Tamanho máximo pasta por grupo: 1Gb
Tamanho máximo nome arquivo: 10 caracteres, sem espaço, apenas letras, numeros e underscore _
Caminho máximo de pastas dentro de pastas: 5

Use emojis, hifens e underscores para ilustrar a estrutura de pasta de uma forma boa

Armazenar os arquivos na pasta "media\12345@g.us\files"
Criar database para arquivos por grupo/contato e saber onde cada arquivo fica

Nova possibilidade de variável para CustomCommand
!g-addCmd [comando]
"{file-destino\arquivo.xxx}"

Quando o conteudo da mensagem for este {file-xxx}, busca o arquivo espeficado na pasta do grupo e envia ele (ou a pasta).
Funciona exatamente como um alias para !p-baixar {file-destino\arquivo.xxx}


---

## FileManager.js
Não está listando os arquivo na pasta
Permitir que arquivos sejam enviados para pasta "raiz", sem uma pasta especificada

No cabeçalho "Arquivos e Pastas" mostrar em itálico na segunda linha o nome de cadastro do grupo ou o nome do author caso seja chat privado

---

## Function: YoutubeDownloader

Duas funções !yt e !sr

!yt baixa um video do youtube

!sr baixa em formato de áudio

Se for link, baixa direto, se for texto, busca o video antes.

Anexei o arquivo utils/VideoCacheManager.js para ser utilizado em conjunto

Crie o YoutubeDownloader.js nos padrões deste projeto.

Use como exemplo o método de dowlnoad utilizado no arquivo youtube.js fornecido em conjunto

Como buscar video no youtube por string:

const ytSearch = require("youtube-search-api");

ytSearch.GetListByKeyword(txtBusca,false,1).then(resultadoBusca => {

	if videos[0] existe, foi encontrado

});

Ative também os 2 comandos ao mesmo tempo para quando o usuário reagir a mensagem que contenha link do youtube com o emoji ⏬

## functions/FileConversions.js

!getaudio: Tenta converter a mensagem mencionada em um arquivo de audio mp3 e retorna em formato de arquivo. Pode ser usado em mensagens de audio, voz e video

!getvoice: Similar ao getaudio, mas envia no formato voice de mensagem

!volume 0-1000: Pode ser usado em mensagens de audio, voz e video e retorna a midia no mesmo formato mas controlando o volume, 0 = mudo, 100 = mesmo volume, 1000 = 10x o volume original

---

## Stickers
Caso !sticker seja usado (como resposta de mensagem) em um sticker (também vale para a reação 🖼), retorna o arquivo de midia (foto ou vídeo)

## Management.js

# g-addCmd
Permitir que o comando tenha mais de 1 palavra
!g-addCmd bom dia
permite que o comando seja invocado com 'bom dia' e não só 'bom'

# g-setPrefix
Permitir que a função não tenha argumentos, assim o prefixo será vazio e qualquer mensagem poderá ser um comando

# g-info
Novo comando. Mostra todas as informações de cadastro do grupo de forma organizada e legível no whatsapp
No final da resposta, listar também todos os comandos do grupo com suas respostas, sem processar as variáveis, apenas o texto que existe no array responses

# !cmd, !menu
Exibir primeiro os comandos personalizados do grupo na lista

# Filters
Implementar comandos que gerenciam os filtros
!g-filtro-palavra [palavra ou frase]: Adiciona a frase informada como filtro. Enviar o comando novamente para remover. Sempre que adicionar ou remover alguma palavra, mostrar lista de palavras/frases filtradas atualmente
!g-filtro-links: Habilita/desabilita que o bot apague links recebidos no grupo (usar regex pra detectar se a mensagem possui link)
!g-filtro-pessoa [numero]: Habilita/desabilita que o bot apague mensagens recebidas de uma pessoa cujo numero possua o numero informado no filtro (argumento numero precisa ter pelo menos 8 digitos, apenas numeros, limpar o que não for numero automaticamente)
!g-filtro-nsfw: Habilita/desabilita filtro de NSFW


# Filtro NSFW
Criar utils NSFWPredict
Criar função que recebe o caminho para o arquivo e retorna se é NSFW ou não, analisando se os limiares passam de um valor pre definido
Usar algum modulo pronto, podendo se externo (definir no .env executavel se for o caso), como o nsfw-predict em python
Utilize modulos modernos e recomende um modelo atualizado para a detecção.

Todas mensagens que se encaixarem no filtro serão apagadas pelo bot caso ele seja admin.
Se o bot não for admin, não tenta apagar.
Quando o usuário usar qualquer comando !g-filtro, verificar se o bot é admin e avisar o usuário que para utilizar os filtros, é preciso que o bot seja admin

## Nova Funcionalidade:
Possibilidade de criar alias usando variável em comandos personalizados
!g-addCmd batata -> {cmd-!comando argumento}

Enviar '!batata' seria o mesmo que enviar '!comando argumento'

----
# Problema com g-setPrefix
O comando não está mais sendo reconhecido como um comando

# g-info
Adicione também informação sobre o !pastas, apenas o numero de arquivos armazenados e o tamanho total utilizado

# Weather
Remova o !weather do PlaceholderCommands e implemente o Weather.js no functions
O comando !weather ou !clima precisa de argumentos e precisa receber ou o nome da cidade ou a localização (mensagem tipo location) como mensagem mencionada

Gere uma mensagem bonita com emojis para representar o clima atual com temperatura, umidade, sensação térmica, velocidade do vento e o que mais achar interessante.

Abaixo, uma lista com a previsão do tempo das próximas horas (apenas temperatura e tipo de clima, como chuva ou nublado)
No final da mensage, a previsão do tempo para os próximos dias, resumida como a das próximas horas (temperatura e tipo de clima)

--

## Management

Implemente agora os comandos para configurar canais da twitch, kick e youtube.
No modelo do grupo, uma configuração exemplo ficaria assim:

Sempre que configurar um canal, a única midia padrão é a text para "online"
Texto padrão twitch e kick:
⚠️ ATENÇÃO!⚠️\n\n🌟 *{nomeCanal}* ✨ está _online_ streamando *{jogo}*!\n_{titulo}_\n\nhttps://twitch.tv/{nomeCanal}

Para Youtube:
*⚠️ Vídeo novo! ⚠️*\n\n*${video.author}:* _${video.title}_ \n${video.link}

data.twitch = [
{
	"channel": "channelName",
	"onConfig": {
		"media": [{"type": "text", "content": default},{"type": "sticker", "content": "..."}], //
		]
	},
	"offConfig": // mesmo que on, mas pra quando o canal fica off
}]


!g-xxx-canal [canal]: Ativa monitoramento deste canal da twitch, se enviar o mesmo comando novamente, desativa
!g-xxx-midia-on  [canal]: Usado como resposta a uma midia ou mensagem de texto. Se enviado sem parametro, apaga o conteúdo cofigurado das midias e volta o texto on para o padrão
!g-xxx-midia-off  [canal]: Mesmo que on, mas para off, sem parametro, apenas remove todas as midias do off
!g-xxx-mudarTitulo  [canal]: Habilita/desabilita o bot mudar o titulo do grupo quando a live fica on e off. Quando configurar, verifica se o bot é admin, se não for, informa que só é possível mudar o titulo se o bot for admin. Quando habilitar, informe o usuário que ele pode usar os comandos abaixo para definir um titulo personalizado, se não o bot apenas irá alterar a palavra ON para OFF e OFF para ON.
!g-xxx-titulo-on [canal]: Define um titulo personalizado pro grupo quando a live ficar on. Se mandar sem argumentos, remove o titulo personalizado e informa o usuário que apenas será substituida a palavra OFF pra ON e vice versa no titulo do grupo, caso exista.
!g-xxx-titulo-off [canal]: O mesmo que acima, mas para evento offline
!g-xxx-usarIA [canal]: Gera e envia junto também uma mensagem de texto usando o LLMService com IA, prompt padrão "O canal XXX ficou online e está jogando, gere uma mensagem animada para convidar a galera do grupo a participar da stream."

O argumento [canal] é opcional para os comandos de midia e titulo quando existir apenas um canal configurado no grupo.
Se existir mais de um canal configurado, informe o usuário a maneira correta de usar o comando e lista de canais configurado no grupo do mesmo.

## StreamMonitor
Com as informações das streams configurada no grupo, tome as ações necessárias quando o canal fica on ou off (ou video novo no youtube).
Envie para o grupo as mídias e mensagem de texto e altere o titulo do grupo se necessário.
Caso o grupo não tenha titulo on/off personalizado definido, apenas altere a palavra ON para OFF e vice versa. Altere também todos os emojis verde para vermelho e vice versa, por exemplo:
	const emojiMap = {
		'🔴': '🟢',
		'🟢': '🔴',
		'❤️': '💚',
		'💚': '❤️',
		'🌹': '🍏',
		'🍏': '🌹',
		'🟥': '🟩',
		'🟩': '🟥'
	};

---

Atualize o !g-info para mostrat também todos os dados de stream configurado no grupo

--

## Novas funcionalidades de gerência

- !g-apelido [apelido]: Define um apelido pelo qual o bot irá chamar o usuário (ao invés do author.name)
Máximo 20 caracteres. Definido por grupo na base de dados do grupo, propriedade "nicks" {"numero": "123462c.us", "apelido": "batata"}

- !g-ignorar [numero]: Ignora mensagens recebidas de uma pessoa cujo numero possua o numero informado (argumento numero precisa ter pelo menos 8 digitos, apenas numeros, limpar o que não for numero automaticamente)

- !g-mute [string]: Faz com que o bot ignore frases que comecem com essa string, não sendo processadas


## Novo comando (functions)

!listas. Cria listas dentro de grupos que os usuários podem entrar e sair
Comandos: !ll, !listas (list), !lc (create), !ld (delete), !le (entrar), !ls (sair), !lt (titulo
), lr (remove)

- !ll/!listas: Mostra as listas atuais no grupo
- !lc nome1 nome2: Cria as listas com os nomes especificados
- !lct nome Titulo: Cria lista já com um titulo 
- !ld nome1 nome2: Deleta as listas com os nomes especificados
- !le nome: Entra na lista 'nome'
- !ls nome: Sai da lsita 'nome'
- !lt nome Nome da Lista: Define um título para a lista
- !lr lista nome: Apenas para administradores. Remove nome da lista

Também deve ser possível reagir com os emoji de números (1️⃣, 2️⃣ , ...) na lista de listas para entrar e sair das mesmas

Use a pasta da base de dados para armazenar as listas (pasta lists), um arquivo por grupo, assim como os custom-cmd

--- 
Crie um readme.md bonito explicando tudo que está implementado aqui.
Mais detalhes para a introdução do README:
- Imagem centralizada na horizontal (placeholder, me sugira um tamanho que fique bom no github)
- Titulo: ravenabot-ai
- Sobre: Novo código da ravena todo desenvolvido utilizando LLM Claude 3.7 Sonnet
- Livre para uso, sem garantias
Sessão logo após a intrudução: TODO-List com checklist, crie e marque como concluído o que já tem, deixe alguns placeholders que irei preencher
Inclua Instruçoes de instalação como baixar o nodejs  e outros programas.
Para programas externos como image-magic etc. crie novos .md e link eles no readme principal. Já existe versões deste arquivos que devem ser localizadas para PT-bR, ficam na pasta "docs".
Neste sessão fale também sobre o .env e o que deve ser inserido no mesmo
Após a instalaçao, mostre um fluxograma de funcionamento usando markup mermaid.
Após o fluxograma, fale sobre os tipos de comando do bot
Inclua uma sessão sobre como implementar novos comandos (pasta functions), exemplo no arquivo PlaceholderCommands.js

Para cada arquivo dentro da pasta functions, gere um .md explicando o funcionamento do mesmo, detalhes da implementação e programas externos (caso aplicável).

È necessário que exista também um tópico dentro do arquivo mostrandoexemplos de utilização dos comandos  (entrada e saída).

Estes arquivos devem ser apontados em um novo tópico do README.md, me envie apenas o código deste tópico já com os links para cada arquivo e uma breve descrição de cada. Siga o mesmo padrão de formatação do arquivo

--
## CustomVariableProcessor

# Custom
As variáveis lidas no cache.variables, são neste formato:
{
	"aeronavePequena": ["A320", "B738", "B738M", "A320N", "E195", "E195E2", "A321"]
}

Então quando existir, por exemplo, {aeronavePequena}, a variável deve ser substituída por um dos elementos do array, de forma aleatória. Se a variável aparece várias vezes, substituir cada vez por uma outra aleatória, sem repetir caso exista um numero suficiente de elementos para isso.


# Novo process: processAPIRequest

Exemplo de variáveis: 
{API#GET#TEXT#https://example.com/api}

arg1, arg2, etc. devem ser variáveis extraídas do comando, por exemplo

Um comando definido:
"{API#GET#TEXT#https://example.com/api?cidade=arg1&estado=arg2}"

!api_exemplo batata frita
Faria request para:
https://example.com/api?cidade=batata&estado=frita

#TEXT ou #JSON definem o modo como a resposta da API será tratada.

Para #TEXT, o comando retornará a resposta em formato texto na íntegra
Para #JSON, é necessário que o usuário defina um texto de saída formatado com as variáveis de resposta JSON dentro de []

{API#GET#JSON#https://example.com/api?cidade=arg1&estado=arg2
Temperatura: [temperature]
Umidade: [humidity.pct]
}

Isso seria para um objeto de retorno como:
{
	temperature: "12°C",
	humidity: {pct: "10%", absolute: "300"}
}

Também é possível definir #GET, #FORM ou #POST, para o método de envio das variáveis.
GET envia como urlParameters, POST envia dados como JSON, e #FORM envia um post urlencoded
----
# Nova function: RiotGamesCommands

Implemente nova function que possua os seguintes comandos:
!lol [conta]
!wr [conta]
!valorant [conta]

Estes comandos acessam a API oficial da RIOT games (com a chave .env.RIOT_GAMES) para buscar dados sobre a conta de usuário requisitada.
Retorne uma mensagem formatada bonita com emojis mostrando dados relevantes da conta, como ELO atual e outras coisas legais.

Crie um RiotGames.md na pasta docs também explicando o funcionamento, inclua ele na seção de comandos do README.md

Anexei o Weather como exemplo.
---

# Invite System
Quando o bot entrar em um grupo via !g-joinGrupo, pegue as informações do convite de quem enviou para anexar na mensagem de boas vindas
São 3 arquivos envolvidos:
InviteSystem.js: Pega os dados do autor que enviou.
Neste arquivo, ele envia a mensagem "!g-joinGrupo ${inviteCode}"
Faça ele enviar:
!g-joinGrupo ${inviteCode} ${authorId} ${authorName}

Management.js: Possui a implementação do joinGrupo, que deve ser modificada para receber os 2 parametros atuhorId e authorName (pode possuir espaços)
EventHandler.js: processGroupJoin deve pegar os dados do authorId e authorName do comando joinGrupo.
Como não existe um vinculo entre o join e o grupo, os dados do groupJoin devem ser analisados da seguinte forma:
Se o authorId está dentro dos membros do grupo que o bot entrou, considere que este é o grupo o qual foi aceito o convite.
Por exmeplo, no processGroupJoin:
Para cada pendingInvite, pegar o authorId e ver se "JSON.stringify(data).includes(authorID)" (sugestão)


Na base de dados/modelo do Group.js, crie uma nova propriedade: additionalAdmins, um array de numeros (["12345@c.us"]) que sempre são considerados administradores no grupo. Sempre que o bot entrar no grupo, define o usuário que adicionou com um additionalAdmin
Implemente também comando de !g-customAdmin [numero] que permite adicionar/remover pessoas da lista de admins.
Formate automaticamente o numero recebido como 123456789012@c.us para ficar padrão nas base de dados
Na respota do comando, inclua também no final a lista os additionalAdmins atuais, formatados como +DD (DD) 9DDDD-DDDD

Enviei arquivos de documentação como exemplo.

Crie um InviteSystem.md explicando o fluxo de convites (utilize mermaid para uma seção com o fluxograma) e uma linha para adicioná-lo na sessão "Documentação dos Comandos" do README.md
Me envie como artefatos

--

Implementar novas functions.
Para cada uma gerada, crie também o arquivo md explicando a implementação e uso na pasta docs.
Inclui arquivos como exemplos para se basear no padrão de desenvolvimento do projeto.
Envie os arfetatos com o código completo para cada uma das funções geradas.

# StableDiffusionCommands
Acessar a API do SDWebui para gerar imagens e retornar pro usuário
.env.SDWEBUI_URL define a URL base para acessar

!imagine [prompt]

Retorna imagem com dados da geração na legenda (prompt, modelo usado, tempo de geração, etc.)
Antes de retornar a imagem gerada, passe a mesma para o nudenet/censor afim de verificar se ela possui conteúdo NSFW
Se possuir, envie a imagem original gerada sem censura, mas:
- adicione viewOnly: true nas opções do retorno
- Envie uma mensagem extra junto, antes da imagem: 🔞 A imagem gerada pode conter conteúdo potencialmente pornográfico, abra com cautela.

# LembretesCommands
!lembrar

Usar em resposta a uma mensagem acompanhado de uma data. O bot deve guardar isso numa base de dados lembretes.json, bem como as midias necessárias para o lembrete.
Na data especificada, o bot deve enviar a mensagem guardada.
Sugestão de biblioteca: chrono-node para interpretar as mensagens

!lembrar amanhã às 10:00
!lembrar 17/04/2025 07:300
!lembrar 10:00 // data = hoje
!lembrar amanhã // horário padrão: 07:00

# GiphyCommands
!gif [busca]
Busca e retorna na api do giphy (chave em .env.GIPHY_API) um gif aleatório relacinado a busca informada.
Se o a busca não for especificada, retornar um dos gifs populares recentes
Incluir legenda com dados do gif, como titulo, visualizações, etc.

# AnimeCommands
!anime [nome]
Use a biblioteca mal-scraper para buscar informações sobre o anime.

Retorne a imagem de capa e dados como:
🗾 Resultado da busca para '':
	📅 *Lançamento*: ${lancamento} (${data.aired} @ ${data.type})
	🍿 *Gênero*: ${generos}
	🔢 *Episódios*: ${data.episodes} (_${data.duration}_)
	🏆 *Nota:* ${data.score}, ${data.ranked}
	💬 *Sinopse:* ${sinopse.trim()}

Pode ser so texto se não tiver imagem de capa.

# ImdbCommands
!imdb [nome]
Similar ao !anime, mas busca dados no IMDB, use a biblioteca que achar mais adequada

# WikipediaCommands
!wiki [busca]

Busca algum artigo na wikipedia pt-br com este nome e retorna uma mensagem legal formatada com a imagem principal (se existir), titulo, reusmo e tópico principal

# DiceCommands

!dXX

Gira um dado conforme espeficação, por exemplo
!d20 = 0 a 20
!d20+5 = 5 a 25
e outros padrões de rolagem para RPG

# GroupCommands
Adiciona função "!apagar", solicitando ao bot que apague a mensagem que ele enviou
Se for mensagem de outra pessoa, apenas tente apagar se o bot for admin, sem necessidade de retornar erro caso não seja

# Management
!g-pausar
Pausar/continua atividade do bot no grupo. Se pausado, nada do grupo será processado além do comando !g-pausar para voltar ao normal

Sobre o group.paused
É necessário verificar esta propriedade nos messageHandler, EventHandler, ReactionsHandler e também ignorar notificação de streams assincronas e lembretes.
Me envie a parte relevante do código que preciso alterar.

---

# WhatsAppBot

Criar novo método baseado na sendMessage

Esta função deve receber apenas 1 parâmetro: um objeto da classe ReturnMessage

sendReturnMessages(returnMessages)

returnMessages é um array, mas caso receba um objeto apenas, converta para um array de 1 objecto para simplificar o processamento.

Este objeto deve ser definido na models/ReturnMessage.js e deve incluir todas as propriedades utilizados no restante do código, com valores default que achar mais adequados.

Ela contém, obrigatoriamente,  chatId, content e options.

Após processar e analisar todos os dados recebidos da ReturnMessage, chama a sendMessage para executar o envio para cad auma das returnMessages

A ideia é que as functions retornem isto como um SingleTon ou array de SingleTons para melhorar o fluxo do programa.

Crie um ReturnMessageModel.md descrevendo o desenvolvimento deste arquivo

Me envie os códigos como artefatos.

Agora, analise os arquivos enviados que utilizam a função bot.sendMessage e adapte para que os mesmos primero instanciem um objecto da ReturnMessage e utilizem o novo sendReturnMessage ao invés do sendMessage
Complemente a classe ReturnMessage preenchendo o options com os parametros padrões. 

    linkPreview boolean (default: false): Show links preview. Has no effect on multi-device accounts.
    sendAudioAsVoice boolean (default: false): Send audio as voice message with a generated waveform
    sendVideoAsGif boolean (default: false): Send video as gif
    sendMediaAsSticker boolean (default: false): Send media as a sticker
    sendMediaAsDocument boolean (default: false): Send media as a document
    isViewOnce boolean (default: false): Send photo/video as a view once message
    parseVCards boolean (default: true): Automatically parse vCards and send them as contacts
    caption string: Image or video caption
    quotedMessageId string: Id of the message that is being quoted (or replied to)
    groupMentions Array of GroupMention: An array of object that handle group mentions
    mentions Array of string: User IDs to mention in the message
    sendSeen boolean (default: true): Mark the conversation as seen after sending the message
    invokedBotWid string: Bot Wid when doing a bot mention like @Meta AI
    stickerAuthor string: Sets the author of the sticker, (if sendMediaAsSticker is true).
    stickerName string: Sets the name of the sticker, (if sendMediaAsSticker is true).
    stickerCategories Array of string: Sets the categories of the sticker, (if sendMediaAsSticker is true). Provide emoji char array, can be null.
    media MessageMedia: Media to be sent

localize o arquivo em ptbr

No mesmo padrão da classe ReturnMessage, defina uma classe Command para que ela possa ser utilizada nas functions.
Utilize as functions enviadas aqui para definir o padrão da classe.
Crie também a docuemtanção para esta classe

---
Me envie como artefatos completos os arquivos da pasta functions alterados para utilizar o sendReturnMessages e também a classe models/Command.js

Caso a função retorne mais de 1 mensagem, faça proveito do fato do sendReturnMessages receber um array de ReturnMessage

Se precisar de mais algum arquivo pra fazer a implementação correta, me peça antes de prosseguir

---
Implemente uma nova function:

!traduzir [idioma] [texto]

ou

!traduzir [idioma] em resposta a alguma mensagem

Use alguma biblioteca grátis e livre para a tradução.

Também deve ser possível reagir a uma mensagem com a bandeira do país para solicitar a tradução. Use todos os emojis de bandeira possíveis.

----
Caso precise de algum arquivo ou informação extra, me peça antes de prosseguir.

# Adequação Management.js e FixedCommands.js
Refatorar os retornos para utilizar a classe `models/ReturnMessage`

# SuperAdmins
Definidos no .env como
SUPER_ADMINS=123456@c.us,789041@c.us
Id do chat separado por virgula

Implementar arquivi `commands/SuperAdmin.js`
Usar como base para o desenvolvimento o Management.js
O prefixo para estes comandos é 'sa'

Remover estes comandos do Management e transferir para superadmin
- sa-joinGrupo
- addDonateNumero
- addDonateValor

Por enquanto, apenas estes comandos a serem implementadas:
- sa-block [contato]: Bloqueia esta pessoa. O numero pode vir em vários formatos, como "+11 11 9999-9999", ou "111199999999@.cus"
- sa-leaveGrupo [id]: Recebe ID de grupo como 1234556@g.us ou name de cadastro na base de dados (group.name) para buscar o id
- sa-foto: Se estiver na legenda de uma foto, altera a foto do perfil do bot para a foto enviada


# Needs Fixing
- buscar-img está retornando um erro. A API key necessária é grátis, onde posso criar uma?
- RiotGamesCommands não está retornando. Crie um debug melhor para que possamos identificar o problema

----

# Nova function: MuNewsCommands

Similar ao SpeechCommands.processAutoSTT no processNonCommandMessage (EventHandler.js)
Criar MuNews.detectNews que recebe a mensagem de texto e verifica se ela é uma "MuNews"
Caso seja detectado, salvar em arquivo neste formato: data/munews/2025-19-04.news

FixedComand: !news (mesmo arquivo)
!news [data]: A data é opcional, padrão hoje
Busca um arquivo de munews na pasta com a data e retorna o conteúdo do mesmo

Se não existir, informe que ainda não recebeu as Munews desta data e que elas geralmente chega entrem 06:00 e 7:30 da manhã.

Funções exemplo que funcionam, mas que podem/devem ser melhoradas para integração
function extractDate(text) {
	const regex = /(\d{1,2})\s+de\s+([\wÇç]+)\s+de\s+(\d{4})/i;
	const match = text.match(regex);
	
	if (match) {
		const [, day, month, year] = match;
		const monthMap = {
			janeiro: '01',
			fevereiro: '02',
			março: '03',
			marco: '03',
			abril: '04',
			maio: '05',
			junho: '06',
			julho: '07',
			agosto: '08',
			setembro: '09',
			outubro: '10',
			novembro: '11',
			dezembro: '12'
		};
		
		const formattedMonth = monthMap[month.toLowerCase()];
		const formattedDay = day.padStart(2, '0');
		
		return `${year}-${formattedMonth}-${formattedDay}`;
	}
	
	return false;
}

function parseJrMunews(msgBody){
	const mensagem = msgBody.toLowerCase();

	/*
		MsgBody tem que tger:
		- 'vinimunews' nos primeiros 200 caracteres
		- a data nos primeiros 200 caracteres
		- ter mais de 5 mil caraceteres
		- ter vindo de um grupo com id especifico definido em .env.GRUPO_MUNEWS

	*/
	if(mensagem.length > 5000){
		const header = mensagem.substring(0,200).toLowerCase();
		if(header.includes("vinimunews")){
			const data = extractDate(header);
			if(data){
				// Verificar se já existe um arquivo pra essa data
				// Se não existir, criar o mesmo e colocar o conteúdo da mensagem (original) dentro dele
			} 
		} 
	}

	return false;
}


# Nova function: LastFMCommands

Código de exemplo para adaptar para este bot nos padrões dos outros commandos:
`
const { loggerInfo, loggerWarn } = require("./logger");
var LastFmNode = require('lastfm').LastFmNode;

/*
Application name 	ravenabot
API key 	62f5658e810b6148fa70c87de866e73f
Shared secret 	bca8f01839bd4f107edc0670a75e0625
Registered to 	moothz
*/


var lastfm = new LastFmNode({
  api_key: process.env.LASTFM_APIKEY,	// sign-up for a key at http://www.last.fm/api
  secret: process.env.bca8f01839bd4f107edc0670a75e0625,
  useragent: 'moothz/v0.1 ravenabot' // optional. defaults to lastfm-node.
});


function formatarTS(ts){
	if(ts){
		const d = new Date(ts*1000);

		const dia = (d.getDate() < 10) ? `0${d.getDate()}`: d.getDate();
		const mes = (d.getMonth() < 9) ? `0${d.getMonth()+1}`: d.getMonth()+1;
		const ano = (d.getFullYear());
		const hora = (d.getHours() < 10) ? `0${d.getHours()}`: d.getHours();
		const minuto = (d.getMinutes() < 10) ? `0${d.getMinutes()}`: d.getMinutes();

		const data = `${dia}/${mes}/${ano}`;
		const horario = `${hora}:${minuto}`;
		
		return `${data} às ${horario}`;
	} else {
		return "??/??/???? às ??:??";
	}
}

function getUserInfo(usuario, callback){
	loggerInfo(`[last.fm][getUserInfo] -> ${usuario}`);
	var request = lastfm.request("user.getInfo", {
		user: usuario,
		handlers: {success: (data) => callback(data.user), error: (e) => callback(false)}
	});
}

function getUserRecentTracks(usuario, callback){
	loggerInfo(`[last.fm][getUserRecentTracks] -> ${usuario}`);
	var request = lastfm.request("user.getRecentTracks", {
		user: usuario,
		limit: 1,
		handlers: {success: (data) => callback(data.recenttracks.track[0]), error: (e) => callback(false)}
	});
}

function getUserTracks(usuario, periodo, callback){
	loggerInfo(`[last.fm][getUserTracks] -> ${usuario} (${periodo})`);
	var request = lastfm.request("user.getTopTracks", {
		user: usuario,
		period: periodo,
		limit: 3,
		handlers: {success: (data) => callback(data.toptracks.track), error: (e) => callback(false)}
	});
}

function getUserArtists(usuario, periodo, callback){
	loggerInfo(`[last.fm][getUserArtists] -> ${usuario} (${periodo})`);
	var request = lastfm.request("user.getTopArtists", {
		user: usuario,
		period: periodo,
		limit: 3,
		handlers: {success: (data) => callback(data.topartists.artist), error: (e) => callback(false)}
	});
}


function processalastFM(u, callback){
	loggerInfo(`[processalastFM] Usuario: ${u}`);
	getUserInfo(u, (usuario) =>{
		getUserTracks(u, "overall", (musicas) => {
			getUserArtists(u, "overall", (artistas) => {
				getUserRecentTracks(u, (recente) => {
					console.log("usuario: ", usuario);
					console.log("musicas: ", musicas);
					console.log("artistas: ", artistas);

					console.log("recente: ", recente);
					if(usuario && musicas && artistas && recente){
						const ouvindoAgora = "";
						const scrobbles = 10;
						const idade = parseInt(usuario.age) > 0 ? `, ${usuario.age}` : "";
						const subscriber = parseInt(usuario.subscriber) ? "👑 " : "";
						const dataRegistro = formatarTS(parseInt(usuario.registered.unixtime));

						const nowPlaying = recente["@attr"]?.nowplaying == "true";

						const quando = nowPlaying ? "Ouvindo _agora_" : "Ouvido por último";
						const dataQuando = nowPlaying ? "" : ` _(em ${formatarTS(parseInt(recente.date.uts))})_`;
						const retorno = `📻 _last.fm_ ${subscriber}*${usuario.name}* _(${usuario.country}${idade})_
	🍼 Usuário desde *${dataRegistro}*
	🎶 *${usuario.playcount}* scrobbles
	🎙 *${usuario.track_count}* músicas e *${usuario.album_count}* albuns de *${usuario.artist_count}* artistas diferentes

	🎧 *${quando}*: ${recente.artist["#text"]} - _${recente.name}_${dataQuando}

	📊 *Top Artistas*
		🥇 ${artistas[0]?.name ?? "-"}
		🥈 ${artistas[1]?.name ?? "-"}
		🥉 ${artistas[2]?.name ?? "-"}

	📊 *Top Músicas*
		🥇 ${musicas[0]?.artist?.name ?? "-"} - _${musicas[0]?.name ?? "-"}_
		🥈 ${musicas[1]?.artist?.name ?? "-"} - _${musicas[1]?.name ?? "-"}_
		🥉 ${musicas[2]?.artist?.name ?? "-"} - _${musicas[2]?.name ?? "-"}_


🔗 ${usuario.url}`;
						callback(false, [{msg: retorno, react: "📻", reply: true}]);
					} else {
						callback(false, [{msg: `*lastm.fm*: Ocorreu um erro buscando os dados do perfil '${u}'. Verifique o nome e tente novamente.`, react: "❌", reply: true}]);
					}
				});
			});
		});
	});
}

module.exports = { processalastFM }
`
----

# ReactionHandler
Importação automática das functions para preencher vetor reactionCommands

Assim como o FixedCommands, este arquivo deve implementar uma loadCommands em this.functionsPath
Lendo todos os arquivos js e buscando pelo export command

O reactionCommands deve ser preenchido da mesma maneira que é atualmente:

{
	"🙂": "methodName"
}

Apenas os commands que tiverem a propriedade reactions.trigger devem ir para esta lista
reactions.trigger pode ser apenas 1 emoji ou 1 vetor de emojis. Se for um vetor, incluir múltiplas entradas no reactionCommands


--
# SpeechCommands com AllTalk
Refatore este arquivo.
* Não será mais usado eSpeak
* Não será mais usado vosk-transcriber

A partir de agora, use a API local do "AllTalk V2"
O endereço base deve ser definido na .env como

ALLTALK_API=http://localhost:7852/

## Text-to-speech
* Use o modelo XTTS 
Existe mais de um character.
Crie um objeto que define eles:
{
"ravena": "ravena_sample.wav",
"mulher": "female_01.wav",
"homem": "male_01.wav",
"clint": "Clint_Eastwood CC3 (enhanced).wav",
"morgan": "Morgan_Freeman CC3.wav"
}

Uso:
!tts-[character]
O character padrão é "ravena" (para usar quando usuário informar !tts apenas)

Você pode definir os comandos de personagem usando um for:
[... value/keys dos characters ...].forEach(effect => {
  commands.push(
    new Command({}))...

## Speech-to-text
* Use o modelo whisper turbo
Mantenha a otimização pelo LLM, mas como uma variável opcional na chamada da função (padrão: true)
---

# Novo Menu

O menu deve ser organizado da seguinte maneira:

[header]

1. Comandos Personalizados do grupo
Lista os comandos personalizados deste grupo

2. Comandos Fixos
Aqui deve-se separar os comandos por Command.category
Crie um objeto para definir um emoji pelo nome de categoria:
{
	"geral": "📃",
	...
}

A ordem das chaves deste objeto deve definir também a ordem na qual as categorias são apresentadas.

Os comandos possuem a propriedade "group", utilizada para agrupar os comandos na mesma linha. Eles devem ser agrupados para comandos que possuem o mesmo "group".
A descrição a ser usada é a do primeiro definido.
Exemplo:
!d4, !d6, !d10: Rola um dado de X faces


Se o comando possui a propriedade "hidden", ele não deve aparecer no menu.
O header deve ser lido do arquivo data/cmd_header, arquivo de texto.

3. Comandos de gerenciamento

## Ordenamento
Crie um vetor onde é possivel colocar em ordem os comandos por nome.
Este vetor pode conter comandos que não existem e também não precisa conter todos os comandos.
Os comandos que não estiverem neste vetor, ficam após os que estiverem, na sua ordenação original.

----
Refatore o arquivo NSFWPredict.js para utilizar o exec e capturar o JSON da saída. Não crie um script python.

Implemente também uma função que recebe um objeto MessageMedia da biblioteca whatsapp-web.js, a qual decodica o mesmo, salva numa pasta tempo de depois chama/retorna a detectNSFW com o caminho do arquivo temp, apagando o mesmo logo em seguida.


"configs.nsfwpredict" é uma variável que contém o caminho completo do comando já com o modelo especificado, ex.:
'...Python310\\Scripts\\nsfw-predict.exe --saved_model_path "C:\\mobilenet_v2_140_224"'

Aqui está um código de exemplo que já utilizei e funciona bem, mas siga os padrões do projeto.
`
async function isMessageMediaNSFWSync(attachmentData, limiar, callback){

	let nRand = Math.floor(Math.random() * 1000000); 

	//let buff = new Buffer(attachmentData.data, 'base64');

	let buff = Buffer.from(attachmentData.data, 'base64');

	const arquivoTempEntrada = path.join(configs.rootFolder,"media","temp",`isnsfw-${nRand}.${mime.extension(attachmentData.mimetype)}`);

	const pctDistort = getRandomInt(20,65);

	loggerInfo(`[isMessageMediaNSFWSync] IsNSFW? ${arquivoTempEntrada} (${arquivoResumido(attachmentData.data)})`);

	fs.writeFileSync(arquivoTempEntrada, buff);

	loggerInfo(`[isMessageMediaNSFWSync] ${configs.nsfwpredict} --image_source	"${arquivoTempEntrada}"`);

	try{

		//mogrify -resize 512x512^ -liquid-rescale 50% -scale 200% manu1.jpg

		exec(`${configs.nsfwpredict} --image_source "${arquivoTempEntrada}"`, (error, stdout, stderr) => {

			//loggerInfo(`[isMessageMediaNSFWSync] stdout: ${stdout}`);

			const output = extractJSON(stdout);

			if(output){

				//loggerInfo(`[isMessageMediaNSFWSync] output: ${JSON.stringify(output,null,"\t")}`);

				let resultado;

				if(Array.isArray(output)){

					resultado = Object.values(output[0])[0];

				} else {

					resultado = output[arquivoTempEntrada] ?? output;

				}

				const maiorRating = Math.max(resultado?.sexy,resultado?.porn,resultado?.hentai,0);

				loggerInfo(`[isMessageMediaNSFWSync] maiorRating: ${maiorRating} / resultado: ${JSON.stringify(resultado)}`);

				let nsfw = (maiorRating > limiar) && resultado.neutral < 0.5;

				apagarArquivo(arquivoTempEntrada, 1800000);

				callback(nsfw);

			} else {

				loggerInfo(`[isMessageMediaNSFWSync] Erro lendo arquivo '${arquivoTempEntrada}'`);

				callback(false);

			}

		});

	} catch(e){

		loggerWarn(`[isMessageMediaNSFWSync] Erro mogrifying await spawn:\n${e}`);

		//loggerInfo(e.stdout.toString());

		//loggerInfo(e.stderr.toString());

		loggerWarn(e);

		callback(false);

	}

}`

---
# Nova função: Blocked Ignore
Ao inicializar o bot (READY), invoque o método client.getBlockedContacts() e armazene em uma variável acessível por outras partes do código (WhatsaAppBot.js) a lista destes contatos bloqueados.
A ideia é que quando o bot receber um evento de um destes contatos dentro de grupo, a pessoa seja ignorada, diretamente no EventHandler.

# Nova função: Interação automática
No CommandHandler->checkAutoTriggeredCommands, verifique se o grupo permite interações (grupo.interact.enabled)
Caso permita, o bot tem grupo.interact.chance de interagir, onde o valor 1000 é o máximo e representa 10% de chance
Cooldown: g-interagir-cd

## Management: !g-interagir
Criar comandos para controlar a interação
!g-interagir: Ativa/desativa o grupo.interact
!g-interagir-cd [tempo minutos]: Tempo de cooldown entre interações, padrão: 30 minutos, minimo 5 minutos, maximo 30 dias
!g-interagir-chance [1-1000]: Chance do bot interagir, 1 = 0.1%, 1000 = 10%

# LoadReport
O report está funcionado bem.
Nova funcionalidade: Atualiza status do whatsapp com informações da carga
bot.client.setStatus(string)

Formato:
{loadEmoji} DD/MM hh:mm | {msgs/h}m/h|!cmd, !info | ravena.moothz.win

[msgs/h]: A carga é medida em mensagens por hora, baseada nos últimos 3 reports

[loadEmoji]
Escolhe um emoji com base na carga atual do bot (msgs/h)
A medida máxima é acima de 2000
loadLevels = ["⬜", "🟩", "🟨", "🟧", "🟥", "⬛"]


# Bot Joins Group
EventHandler -> // Caso 1: Bot entrou no grupo
Atualmente, ele envia um astring botInfoMessage quando entra.
Ao invés da string, ler conteudo do arquivo "data/textos/groupJoin.txt", texto plano

Usar a string apenas como fallback.

# Problema com g-autoStt
A propriedade para autoStt não está sendo salva na base dados, apenas em tempo de execução.
Verificar o problema e corrigir.

--
Migração de dados

Desenvolva um script em nodejs capaz de realizar a migração de dados da versão antiga para a nova.

Fontes:
- dados.json
- frases-zap.json
- roleta.json
- lists.json

As fontes virão de 4 pastas (idRavena) diferentes e devem ser unificadas em uma importação apenas. Caso existam grupos repetidos no cadastro, considerar apenas o primeiro processado.

O que gerar:
- data/groups.json
- data/roletarussa.json
- data/custom-cmd/######@g.us.json
- data/media/xxxxxxx.yyy
- data/lists/######@g.us.json

Analisar as semelhanças dos arquivos groups.json vs dados.json e me perguntar se estão ok antes de prosseguir.

Como proceder:

1. Ler os arquivos dados.json que possui o array "grupos", neste array existem os dados de todos os grupos cadastrados
2. Manter estes dados na memória, pois será necessário associar o "nome"+"numeroGrupo"
3. Converter para o groups.json
4. Copiar arquivos das configurações do grupo: twitch.imgOn etc. para a pasta data/media
5. Ler o arquivo frases-zap.json e agrupar as frases pela propriedade "canais", que representa quais grupos possuem o comando.
6. Para cada grupo, descobrir o "numeroGrupo" pelo "nome" (canal) e criar o respectivo data/custom-cmd/[numeroGrupo].json
7. Copiar os comandos no novo formato para os arquivos de custom-cmd de cada grupo
8. Todas as respostas em frases-zap que seguem o padrão: img-xxxx, gif-xxxx, vid-xxxx, sfx-xxxx, stickerguif-xxxx, stickerimag-xxxx, nomeArquivoMidia-xxxx são arquivos que devem ser copiados. xxxx é o nome do arquivo, que fica na pasta "C:\ravenas\[idRavena]\media\[tipo]\xxxx"
A pasta do [tipo] para cada:
- img => images
- gif => gifs
- vid => videos
- sfx => audios
- sticker => stickers
- stickerguif => stickers
- stickerimag => stickers
Legendas ´podem seguir 2 padrões, com o nome do arquivo no começo ou no final
"img-nomeArquivo.jpg legenda" <==> "{image-nomeArquivo.jpg} legenda"
"legenda img-nomeArquivo.jpg" <==> "{image-nomeArquivo.jpg} legenda"
9. Adaptar e gerar o atual roletarussa.json a partir do antigo roleta.json
10. Adaptar o lists.json e gerar os lists/[numeroGrupo].json (necessário associar o nome com o numeroGrupo novamente)


- img => {image-...}
- gif => {gif-...}
- vid => {video-...}
- document => {document-...}
- sfx => {voice-...}
- sticker => {sticker-...}
- stickerguif => {sticker-...}
- stickerimag => {sticker-...}

---
As mensagens de gerência só podem ser utilizadas por:
* admins do grupo: GroupChat.participants.participant.isAdmin
* Group.additionalAdmins
* SuperAdmin

Para pegar o GroupChat, você pode utilizar client.getChatById(group.id) ou message.origin.getChat()

Implemente uma função genérica isAdmin que possa ser utilizada em outros lugares do código, como no WhatsAppBot.js isUserAdminInGroup
---
# Nova Função: Ranking de Mensagens
Cada vez que o bot receber uma mensagem, gravar a qtdMensagens que a pessoa enviou já para o grupo ou PV
Base de dados
- data/ranking/[groupId].json
- data/ranking/[bot-number@c.us].json // caso seja no PV do bot
O ID pode utilizar o message.origin.from para facilitar a implementação

Formato:
{
	"nome": "Nome do Autor", // atualiza sempre que receber mensagem, pois pode mudar
	"numero": "123456@c.us",
	"qtdMsgs": 10
}

Implementar comando !faladores (GeneralCommands.js, category: geral) que mostra o ranking de faladores no grupo que o comando foi enviado.

# !g-apelido -> !apelido
Como o !g- é apenas para adminstradores, remover o !g-apelido do Management e transformá-lo em um GeneralCommands chamado !apelido
Seta um apelido pro usuário dentro do grupo que foi enviado.
Sempre que uma nova mensagem desse usuário for recebida, o bot deve alterar o pushname/name para o apelido da base de dados, caso exista.
Assim, o usuário sempre será tratado pelo seu apelido dentro do grupo
Minimo: 2 caracteres
Máximo: 20 caracteres, apenas truncar, sem necessidade de retornar erro.


# Novo comando Management: !g-manage
O !g-manage já existe para o PV do bot, implementado no processManagementCommand. Iso deve ser mantido.
Criar o comando novo no Management que não recebe argumentos, mas é o equivalente de enviar !g-manage [nomeDoGrupo] no pv do bot

# Mudança no privateManagement
Quando o usuário está gerenciando o grupo pelo PV do bot, o bot está enviando as mensagens de respostas dos comadnso dentro do gurpo, mas ele deveria responder o usuário no própvio pv do bot.
A ideia desta função é não poluir o grupo durante a configuração do mesmo.


# CustomVariableProcessor.js
Novas variáveis a serem processadas:

 - Você girou o dado de 150 e deu: {rndDado-150}!
 - Você chutou algo entre 20 e 60 e deu: {rndDadoRange-20-60}!
 - {rndDado-10} + {randomPequeno} + {rndDadoRange-5-13} = {somaRandoms}
 - Esse comando já foi executado {contador} vezes!
 - O grupo aqui se chama {nomeCanal} ou {nomeGrupo}!
 - {randomPequeno} {randomMedio} {randomGrande} {randomMuitoGrande}
 - {data-hora}:{data-minuto}:{data-segundo} {data-dia}/{data-mes}/{data-ano}
 - {nomeAutor} é quem mandou a mensagem, {mention} é o nome de quem foi marcado na mensagem respondido em quote
 - {mention-12345678@c.us} faz com que a pessoa seja mencionada mensagem, esta variável apenas é apagada do retorno quando processada


---
No WhatsAppAbot.processStreamEvent o bot precisa verificar
- Se o grupo não está pausado 
- se ainda faz parte do grupo antes de tentar enviar as mensagens, pois ele pode ter sido removido.

Caso o bot não faça mais parte do grupo, definir o mesmo como pausado.
---

Modificação Grande - Alteração do WhatsAppBot.js para ser mais genérico
A ideia é que esse arquivo possa ser substituido por outro, como O WhatsaAppBotBailey ou talvez um TelegramBot, DiscordBot, etc.
Esse é o wrapper da plataforma que vai receber/enviar mensagens, etc.

Estas funções são genéricas e não deveriam estar neste arquivo:
- loadChannelsToMonitor
- handleStreamOnline
- handleStreamOffline
- handleNewVideo
- processStreamEvent
- sendEventNotification
- sendAINotification
- changeGroupTitle: Nome da função changeGroupTitleForStream

Analise quais destas funções já estão corretamente implementadas no StreamSystem.js para que o WhatsAppBot.js possa ser reorganizado apenas com o que é relevante para ele.

Adicione uma variável no começo do streamSystem chamada:
const debugNotificacoes;

Se true, sempre que existir um evento novo, envie a mensagem também para o canal bot.grupoLogs
Envie também as midias e mensagens caso configurado no grupo/canal/plataforma
----
Modificações no sistema de streams
Isto irá gerar artefatos grandes, então me envie apenas a parte do código que for alterada, separando cada função modificada ou criada em um artefato
Na primeira linha do arfato, coloque um comentário especificando o arquivo onde ele deve ser inserido ou alterado.

# Gerenciamento de midia para notificação de streams
g-xxxx-midia-on/off
Atualmente, o código está apagando as mídias existente do array, mas ele deveria adicionar.
É possível ter 1 mídia de cada tipo: text, image, sticker, audio, video
Altere o comando para
g-xxxx-midia [on/off]
Onde on ou off é um argumento, Se não existiri argumento, considerar on
Aproveite as funções existentes (setTwitchOnlineMedia, setTwitchOfflineMedia, etc.), apenas crie um novo handler que encaminha/retorna a correta


## g-xxxx-titulo
Mesma mudança do anterior, usar o on/off como argumento
g-xxxx-titulo [on/off] [tituloNovo]
Se enviado sem um titulo ou argumentos, apagar a propriedade

## Novo comando: Apagar midia
- g-xxxx-midia-del [on/off] [tipo]
Remove midia do tipo informado no comando. Necessário todos os argumentos

## Novo comando: Foto do grupo por evento stream
- g-xxxx-fotoGrupo [on/off]
Se enviado sem argumento, remove a foto.

Pode vir na legenda de uma foto ou como resposta (quote) de uma mensagem tipo foto
Define a foto que o bot irá alterar como imagem do grupo quando a stream ficar on ou off
O bot deverá tentar trocar a foto apenas se essa propriedade estiver definida.

## Novo Comando para o StreamCommands:
!streamers: Lista, separado por plataforma, todos os streamers online no momento, mostrando algo como

Streamers que usam a *ravenabot*:

💜 *Twitch*:
	- *nomeStreamer*: Jogo _(qtdViewers)_
	- *nomeStreamer*: Jogo _(qtdViewers)_

💚 *Kick*:
	- *nomeStreamer*: Jogo _(qtdViewers)_
	- *nomeStreamer*: Jogo _(qtdViewers)_

## Novos Comandos para o StreamCommands:
!live [nomeDoCanal] (twitch)
!live-kick [nomeDoCanal]

Busca informações da Live especificada no comando
Se for enviada sem argumentos, gera 1 mensagem para cada live configurada no grupo
A mensagem deve ser composta de uma Ffto com o Thumbnail da API e a descrição da stream na legenda: Titulo da live, Jogo atual, viewers, hora que começou e atual tempo de stream
Caso necessário, criar e importar função para obter estes dados via nome do canal na services/StreamMonitor.js ou StreamSystem.js (o que achar mais adequado)

## Novo Comando para Management
!g-variaveis
Lista todas as variáveis possíveis de usar no bot (na criação de comandos), separado pelas fixas definidas no CustomCommands e as que ficam no custom-variables.json


## Nova funcionalidade StreamSystem para Youtube
Quando vier um status 404 na busca do canal (nome errado, por exemplo), remover esta canal do monitoramento do grupo e enviar mensgem no grupo avisando "o canal do youtube com o nome XXX não foi encontrado e foi removido do monitoramento, verifique o nome correto"
----

# Fix Management plataforma-midia
O comandos de adicionar midia estão sendo reconhecidos, mas quando uma midia nova é adicionada, as outras esão sendo apagadas do vetor twitch.onConfig.media  (também vale para as outras plataformas).
A pessoa pode enviar 1 conteúdo de cada tipo, então existem 2 casos em que uma midia seria apagado do vetor "media"
* no comando midia-del: está funcionando ok
* No comando midia quando enviar algo que já existe (enviar um audio para um que já tem audio sobreescreveria o antigo)

Aproveitando que a função será alterada, quando adicionar uma midia, coloque na mensagem de retorno o tipo de midia que foi adicionada e sugira o comando correto para remove-lá ao final da mensagem


# Novo comando SuperAdmin
!simular [twitch/kick/youtube] [canal] [on/off]

Dispara um evento de live on ou off para uma das plataformas.
Usar nomes placeholders para o titulo, nome do jogo, data, etc.

----

# Novos comandos de Stickers
Estes comandos podem utilizar os métodos existentes pra criar stickers, mas antes de chegar neles, manipular a midia recebida nos formatos especificados, como um middleware

Command -> Middleware de Manipulaçõa -> Comando de Sticker original

Usar o ffmpeg pra videos e o sharp para imagem (caso não sej apossivel o FFMPEG, voce pode escolher um ou outro).
As duas estão disponíveis para uso no código:
//const ffmpeg = require('fluent-ffmpeg');
//const sharp = require('sharp');

- !sq/stickerq: Faz o sticker ficar quadrado, centralizando o corte (descarta o top e bottom)
- !sqc/stickerqc: Faz o sticker ficar quadrado, descaratando o bottom
- !sqb/stickerqb: Faz o sticker ficar quadrado, descaratando o top


---

# Novos comandos
Para manter o padrão do projeto, enviei o Giphy e o Anime como exemplos.
Faça os requests das APIs abaixo usado axios no mesmo padrão.
Placas de carros brasileiras

## Comum para os comandos
Crie um validador de placas brasileiras:
LLL####
LLL#l## -> onde l é uma letra de A até J (0 = A, 1 = B, ..)
O argumento pode vir em vários formatos, normalize ele para ficar sem espaços e tudo minusculo.
Ex.:
abc 1234 -> abc1234
a bc1234 -> abc1234
abc-1234 -> abc1234

Alguns casos a pessoa pode colocar a letra 'o' no lugar dos numeros, considere '0'.



## !sipt, !instasipt
Usa como exemplo o arquivo sipt.js para criar as chamadas do comando
!sipt [placa]
O sipt deve fazer parte do PlacasCommands.js e o configs.js não deve mais existir. As configurações devem ser colcoadas todas no .env


## !placa [placa]
Use como exemplo o arquivo placas.js enviado, que já tem uma função que chama corretamente a API.
A chave da API deve ser buscada no .env.
Use o mesmo validador de placas antes de fazer a chamada da API.

----


# Novas funcionalidades no CommandHandler

## Cooldowns
Quando buscar um comando fixo ou personalizado, deve-se manter em memória um novo objeto que track o cooldown dos comandos, por grupo. (timestamp last used)
Exemplo:

cooldowns = {
	"123456@g.us":{
		"imagine": 1745505948,
		"ai": 1745505600
	},
	"12345@c.us":{
		...
	}
	...
}

Então antes de confirmar a execução do comando, deve-se se verificar se o mesmo não está em cooldown naquele grupo (ou chat privado)

Esta variável deve ser mantida em memória, mas de tempos em tempos (a cada 1 minuto, por exemplo), deve ser salva em data/cooldowns.json.
Sempre que o bot for inicializado, deve ser lido este comando para ficar memmória, evitando que perca o cooldown quando o bot reiniciar.

Se estiver em cooldown, o bot deve reagir com: ⏰ e responder :
	- "O comando '!imagine' está em cooldown, aguarde 12s para usar novamente."
	- "O comando '!ai' está em cooldown, aguarde 20m para usar novamente."

Para evitar spam, caso já tenha sido enviado uma mensagem de cooldown para este comando, apenas reagir com ⏰
Quando o comando sai de cooldown, na próxima vez já deve-se enviar a mensagem de aviso novamente.


## Hora e dia de funcionamento
Envie apenas o código que deve ser adicionado e em qual parte da função adicionar.

Comandos fixos ou personalizados podem ter hora e dia definidos pra acontecer, na propriedade 'allowedTimes'
Se a propriedade não está definida, ignorar.

Permitido das 3 da manhã até ás 3 da tarde, segundas terças e quartas
{
	"start": "03:00"
	"end": "15:00",
	"daysOfWeek": ["seg", "ter", "qua"]
}

Permitido das 9 da noite até 5 da manhã nos sábados e domingos:
{
	"start": "21:00"
	"end": "05:00",
	"daysOfWeek": ["sab", "dom"]
}


## Necessário implementar novos comandos de gerenciamento
Envie apenas as funções nececessárias e o que adicionar no commandMap.

!g-cmd-setHoras 00:00 20:00
!g-cmd-setDias seg sex sab

Se enviar sem argumentos, remove a definição (false), permitindo em qualquer hora/dia

----

# StreamMonitor: nova função
Crie uma funções similares a _pollTwitchChannels e _pollKickChannels, mas que só buscam os canais especificados no arugmento
Este canal não precisa estar sendo monitorado previamente.
A função deve apenas buscar na API e ao invés de chaemar um emit.streamOnline, retornar o objeto que seria do evento (um array caso seja mais de 1 stream, um para cada stream)

getTwitchLiveStatus(channels) e getKickLiveStatus(channels)

Channles pode ser string ou array de string
Se for string, busca só de uma e retorna só 1 objeto de status
Se for array, busca de todas e retornar um array de objetos de status

# StreamCommands.js
Edite a função getStreamInformation para utilizar o getTwitchLiveStatus removendo o retorno "`O canal ${channelName} (${platform}) não está sendo monitorado.`", afinal, agora a busca não depende dos canais monitorados.

----

Atualize o README.md com todos os novos detalhes do projeto.
Ignore as	Todolists

A parte "Documentação dos Comandos" por enquanto fica vazia, em um próximo prompt irei enviar os arquivos das functions para você analisar e fazer apenas esta seção. Sobre isso, me encaminho após o readm.me um prompt que eu possa te enviar e quais arquivos são relevantes aqui para que você possa fazer isso sem estoutrar o limite de arquivos importados.

--

Atualize 2 partes do README.md
- Tipos de Comandos: São 4 tipos, o outro que falta (numero 4) são os comandos de SuperAmin, que inclui o arquivo agora para você analisar

- Documentação dos Comandos: Para arquivo da pasta functions, gerar um artefato de arquivo MD com a documentação do mesmo, seguindo o mesmo padrão do README.md.
Linkar estes arquivos nesta sessão do readme, com um breve descrição, exemplo:

- [Comandos de Busca](docs/SearchCommands.md) - Ferramentas para realizar buscas na web

----
Se baseando no arquivo WhatsAppBot.js que utiliza a biblioteca whatsapp-web.js (https://github.com/pedroslopez/whatsapp-web.js), crie um WhatsAppBotBaileys.js utilizando a biblioteca Baileys (https://github.com/WhiskeySockets/Baileys).

Considere que o WhatsappBot.js é uma interface e implemente todos métodos para que eu possa simplesmente instanciar um objeto new WhatsAppBotBailyes no index, assim como é feito com o original.

----------

Novas mudanças

# CustomVariableProcessor
- Nova: {membroRandom} - Pega nome/apelido de um membro random do grupo
- Variável {mention} quando não tiver quoted, escolhe um membro random do grupo para dar mention

# EventHandler.js

generateGreetingMessage novas variáveis: 
{tituloGrupo} - Titulo do grupo (chat.name)
{nomeGrupo} - Nome do grupo (group.name)
{nomePessoas} - Nome das pessoas que foram adicionadas separado por virgula
{plural_S} - Se tiver mais que 1 pessoa add, vira S, se não, vazio
{plural_M}, {plural_s}, {plural_m}, {plural_esao} - Assim como a anterior, mas outras letras


# WhatsAppBot.js
Adiciona nova propriedade no construtor: otherBots
Adiciona os otherBots ao blockedContacts para que elas ignorem mensagens uma das outras
No index.js, pode ser feito com map do rBots

# LLMService.js
Nova funcionalidade: Se der erro em algum model, tenta outro do array de models.
Caso todos do openrouter resultem em erro, muda para o openAICompletion com local: true

const freeModels = ["google/gemini-2.0-flash-exp:free", "meta-llama/llama-4-maverick:free", "deepseek/deepseek-chat-v3-0324:free", "deepseek/deepseek-r1:free", "qwen/qwq-32b:free", "nvidia/llama-3.1-nemotron-ultra-253b-v1:free"]

Provider padrão: OpenRouter


# Novo comando/function: EmojiKitchenCommands
!emojik 🥹 😗
!memoji 🥹 😗

(Pega os primeiros 2 emojis de argumento)

O retorno é uma imagem PNG, que deve ser enviada como sticker usando:
MessageMedia.fromURL(`https://emojik.vercel.app/s/🥹_😗?size=512`);

Legenda do sticker: Emojik: 🥹+😗 
---

# LLMService.js
Nova funcionalidade: quando não receber um provider, criar nova função getCompletionFromProviders

Esta função irá chamar na sequencia vários providers, caso um dê erro, passa pro próximo.
O erro deve ser mostrado no terminal, como erro 400 ou expiradas solicitações grátis, erro de chave api, etc.

Me diga quais chaves API vou precisar fornecer e colocar no .env

1. API Gemini Oficial gemini-2.0-flash-exp:free
2. API Meta Llama 4 Maverick Free
3. API Deepseek R1 Free
4. API Deepseek Chat V3 free
5. Local LM Studio

Não use o openrouter mais, pois ele tem um limite curto de requests grátis por dia.
Chame os endpoints das APIs próprias de cada provider diretamente. Caso seja necessário, instale módulos NPM para cada um, caso fique mais userfriendly.